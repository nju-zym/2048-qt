#include "EnhancedEval.h"
#include <cmath>
#include <algorithm>
#include <vector>

// 使用SIMD指令优化
#ifdef __SSE4_1__
#include <immintrin.h>
#endif

float EnhancedEval::evaluateCornerMax(const BitBoard& board) {
    // 找到最大值及其位置
    int maxValue = 0;
    int maxRow = -1;
    int maxCol = -1;
    
    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 4; ++col) {
            int value = board.getTile(row, col);
            if (value > maxValue) {
                maxValue = value;
                maxRow = row;
                maxCol = col;
            }
        }
    }
    
    // 如果最大值在角落，给予高分
    if ((maxRow == 0 || maxRow == 3) && (maxCol == 0 || maxCol == 3)) {
        return 1.0f;
    }
    
    // 如果最大值在边缘，给予中等分数
    if (maxRow == 0 || maxRow == 3 || maxCol == 0 || maxCol == 3) {
        return 0.5f;
    }
    
    // 如果最大值在中间，给予低分
    return 0.0f;
}

float EnhancedEval::evaluateSnakePattern(const BitBoard& board) {
    // 检查蛇形模式
    // 理想的蛇形模式是：
    // 大 -> 小 -> 小 -> 大
    // 大 <- 小 <- 小 <- 大
    // 大 -> 小 -> 小 -> 大
    // 大 <- 小 <- 小 <- 大
    
    // 第一行：从左到右递减
    bool row1Decreasing = true;
    for (int col = 0; col < 3; ++col) {
        if (board.getTile(0, col) < board.getTile(0, col + 1)) {
            row1Decreasing = false;
            break;
        }
    }
    
    // 第二行：从右到左递减
    bool row2Decreasing = true;
    for (int col = 3; col > 0; --col) {
        if (board.getTile(1, col) < board.getTile(1, col - 1)) {
            row2Decreasing = false;
            break;
        }
    }
    
    // 第三行：从左到右递减
    bool row3Decreasing = true;
    for (int col = 0; col < 3; ++col) {
        if (board.getTile(2, col) < board.getTile(2, col + 1)) {
            row3Decreasing = false;
            break;
        }
    }
    
    // 第四行：从右到左递减
    bool row4Decreasing = true;
    for (int col = 3; col > 0; --col) {
        if (board.getTile(3, col) < board.getTile(3, col - 1)) {
            row4Decreasing = false;
            break;
        }
    }
    
    // 计算蛇形模式得分
    float score = 0.0f;
    if (row1Decreasing) score += 0.25f;
    if (row2Decreasing) score += 0.25f;
    if (row3Decreasing) score += 0.25f;
    if (row4Decreasing) score += 0.25f;
    
    return score;
}

float EnhancedEval::evaluatePotentialMerges(const BitBoard& board) {
    // 计算潜在合并的数量
    int potentialMerges = 0;
    
    // 检查水平方向的潜在合并
    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 3; ++col) {
            int value = board.getTile(row, col);
            if (value > 0 && value == board.getTile(row, col + 1)) {
                potentialMerges++;
            }
        }
    }
    
    // 检查垂直方向的潜在合并
    for (int col = 0; col < 4; ++col) {
        for (int row = 0; row < 3; ++row) {
            int value = board.getTile(row, col);
            if (value > 0 && value == board.getTile(row + 1, col)) {
                potentialMerges++;
            }
        }
    }
    
    // 归一化得分
    return std::min(1.0f, potentialMerges / 8.0f);
}

float EnhancedEval::evaluateStability(const BitBoard& board) {
    // 计算棋盘的稳定性
    // 稳定的方块是那些不会在任何移动中改变位置的方块
    
    // 计算每个方块的稳定性
    float stability = 0.0f;
    
    // 检查每个非空方块
    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 4; ++col) {
            int value = board.getTile(row, col);
            if (value == 0) continue;
            
            // 检查方块是否被更大的方块包围
            bool stableLeft = col == 0 || board.getTile(row, col - 1) >= value;
            bool stableRight = col == 3 || board.getTile(row, col + 1) >= value;
            bool stableUp = row == 0 || board.getTile(row - 1, col) >= value;
            bool stableDown = row == 3 || board.getTile(row + 1, col) >= value;
            
            // 计算方块的稳定性
            float blockStability = 0.0f;
            if (stableLeft) blockStability += 0.25f;
            if (stableRight) blockStability += 0.25f;
            if (stableUp) blockStability += 0.25f;
            if (stableDown) blockStability += 0.25f;
            
            // 加权计算（较大的方块稳定性更重要）
            stability += blockStability * std::log2(value);
        }
    }
    
    // 归一化得分
    return std::min(1.0f, stability / 64.0f);
}

float EnhancedEval::evaluateRisk(const BitBoard& board) {
    // 计算棋盘的风险
    // 风险低的棋盘不容易导致游戏结束
    
    // 检查空位数量
    int emptyTiles = board.countEmptyTiles();
    if (emptyTiles == 0) {
        // 如果没有空位，检查是否有可能的合并
        for (int row = 0; row < 4; ++row) {
            for (int col = 0; col < 3; ++col) {
                if (board.getTile(row, col) == board.getTile(row, col + 1)) {
                    return 0.5f;  // 有水平合并的可能，风险中等
                }
            }
        }
        
        for (int col = 0; col < 4; ++col) {
            for (int row = 0; row < 3; ++row) {
                if (board.getTile(row, col) == board.getTile(row + 1, col)) {
                    return 0.5f;  // 有垂直合并的可能，风险中等
                }
            }
        }
        
        return 0.0f;  // 没有可能的合并，风险极高
    }
    
    // 空位越多，风险越低
    return std::min(1.0f, emptyTiles / 16.0f);
}
