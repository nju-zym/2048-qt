#include "BitBoard.h"
#include <cmath>
#include <iomanip>
#include <sstream>
#include <random>
#include <chrono>
#include <QMutexLocker>
#include <QDebug>
#include <QFile>
#include <QDataStream>
#include <QDir>
#include <QStandardPaths>

#ifdef _WIN32
#include <windows.h>
#else
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#endif

// 静态成员初始化
std::array<uint16_t, 65536> BitBoard::moveTable[4];
std::array<uint16_t, 65536> BitBoard::scoreTable;
bool BitBoard::tablesInitialized = false;
QMutex BitBoard::tablesMutex;

// 内存映射文件句柄
#ifdef _WIN32
static HANDLE fileMapping = NULL;
static void* mappedData = NULL;
#else
static int fd = -1;
static void* mappedData = nullptr;
#endif

// 查找表文件名
static const QString LOOKUP_TABLE_FILE = "bitboard_lookup_tables.dat";

// 获取查找表文件路径
static QString getLookupTableFilePath() {
    QString cacheDir = QStandardPaths::writableLocation(QStandardPaths::CacheLocation);
    QDir dir(cacheDir);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    return cacheDir + "/" + LOOKUP_TABLE_FILE;
}

// 创建查找表文件
static bool createLookupTableFile() {
    QString filePath = getLookupTableFilePath();
    QFile file(filePath);
    
    if (file.exists()) {
        return true;
    }
    
    if (!file.open(QIODevice::WriteOnly)) {
        qWarning() << "无法创建查找表文件:" << filePath;
        return false;
    }
    
    // 计算文件大小：两个移动表和一个分数表，每个表65536个16位整数
    size_t fileSize = 3 * 65536 * sizeof(uint16_t);
    
    // 写入文件头
    QDataStream out(&file);
    out.setVersion(QDataStream::Qt_5_15);
    
    // 写入魔数和版本号
    out << quint32(0x2048BEEF) << quint32(1);
    
    // 预分配文件空间
    file.resize(fileSize + 8); // 加上8字节的文件头
    
    file.close();
    
    return true;
}

// 使用内存映射打开查找表文件
static bool openLookupTableFile() {
    QString filePath = getLookupTableFilePath();
    
    if (!createLookupTableFile()) {
        return false;
    }
    
#ifdef _WIN32
    // Windows实现
    HANDLE hFile = CreateFileW(
        reinterpret_cast<LPCWSTR>(filePath.utf16()),
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    
    if (hFile == INVALID_HANDLE_VALUE) {
        qWarning() << "无法打开查找表文件:" << filePath;
        return false;
    }
    
    // 创建文件映射
    fileMapping = CreateFileMappingW(
        hFile,
        NULL,
        PAGE_READWRITE,
        0,
        0,
        NULL
    );
    
    CloseHandle(hFile);
    
    if (fileMapping == NULL) {
        qWarning() << "无法创建文件映射";
        return false;
    }
    
    // 映射文件到内存
    mappedData = MapViewOfFile(
        fileMapping,
        FILE_MAP_ALL_ACCESS,
        0,
        0,
        0
    );
    
    if (mappedData == NULL) {
        qWarning() << "无法映射文件到内存";
        CloseHandle(fileMapping);
        fileMapping = NULL;
        return false;
    }
#else
    // POSIX实现
    fd = open(filePath.toUtf8().constData(), O_RDWR);
    if (fd == -1) {
        qWarning() << "无法打开查找表文件:" << filePath;
        return false;
    }
    
    // 获取文件大小
    struct stat sb;
    if (fstat(fd, &sb) == -1) {
        qWarning() << "无法获取文件大小";
        close(fd);
        fd = -1;
        return false;
    }
    
    // 映射文件到内存
    mappedData = mmap(NULL, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (mappedData == MAP_FAILED) {
        qWarning() << "无法映射文件到内存";
        close(fd);
        fd = -1;
        return false;
    }
#endif
    
    return true;
}

// 关闭内存映射文件
static void closeLookupTableFile() {
#ifdef _WIN32
    if (mappedData != NULL) {
        UnmapViewOfFile(mappedData);
        mappedData = NULL;
    }
    
    if (fileMapping != NULL) {
        CloseHandle(fileMapping);
        fileMapping = NULL;
    }
#else
    if (mappedData != nullptr && mappedData != MAP_FAILED) {
        // 获取文件大小
        struct stat sb;
        if (fstat(fd, &sb) != -1) {
            munmap(mappedData, sb.st_size);
        }
        mappedData = nullptr;
    }
    
    if (fd != -1) {
        close(fd);
        fd = -1;
    }
#endif
}

// 预计算的2的幂表，用于快速计算实际值
static const int powerTable[16] = {
    0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768
};

BitBoard::BitBoard() : board(0) {
    // 不再在构造函数中初始化表
    // 表的初始化将在后台线程中进行
}

BitBoard::BitBoard(GameBoard const& gameBoard) : board(0) {
    // 不再在构造函数中初始化表
    // 表的初始化将在后台线程中进行

    // 从GameBoard转换为BitBoard
    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 4; ++col) {
            int value = gameBoard.getTile(row, col);
            if (value > 0) {
                // 将实际值转换为对数值（例如，2->1, 4->2, 8->3, ...）
                int logValue = static_cast<int>(std::log2(value));
                setTile(row, col, logValue);
            }
        }
    }
}

BitBoard::BitBoard(uint64_t board) : board(board) {
    // 不再在构造函数中初始化表
    // 表的初始化将在后台线程中进行
}

int BitBoard::getTile(int row, int col) const {
    if (row < 0 || row >= 4 || col < 0 || col >= 4) {
        return 0;
    }

    int shift = (row * 16) + (col * 4);
    int value = (board >> shift) & 0xF;

    // 将对数值转换回实际值（例如，1->2, 2->4, 3->8, ...）
    return value == 0 ? 0 : powerTable[value];
}

void BitBoard::setTile(int row, int col, int value) {
    if (row < 0 || row >= 4 || col < 0 || col >= 4) {
        return;
    }

    int shift = (row * 16) + (col * 4);

    // 清除该位置的旧值
    board &= ~(0xFULL << shift);

    // 设置新值
    if (value > 0) {
        // 将实际值转换为对数值（例如，2->1, 4->2, 8->3, ...）
        int logValue  = static_cast<int>(std::log2(value));
        board        |= (static_cast<uint64_t>(logValue) << shift);
    }
}

std::vector<BitBoard::Position> BitBoard::getEmptyPositions() const {
    std::vector<Position> emptyPositions;
    emptyPositions.reserve(16);  // 最多16个空位

    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 4; ++col) {
            int shift = (row * 16) + (col * 4);
            if (((board >> shift) & 0xF) == 0) {
                emptyPositions.emplace_back(row, col);
            }
        }
    }

    return emptyPositions;
}

int BitBoard::countEmptyTiles() const {
    int count = 0;

    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 4; ++col) {
            int shift = (row * 16) + (col * 4);
            if (((board >> shift) & 0xF) == 0) {
                count++;
            }
        }
    }

    return count;
}

BitBoard BitBoard::placeTile(Position pos, int value) const {
    BitBoard newBoard = *this;

    // 将实际值转换为对数值
    int logValue = static_cast<int>(std::log2(value));

    int shift       = (pos.row * 16) + (pos.col * 4);
    newBoard.board &= ~(0xFULL << shift);                          // 清除该位置的旧值
    newBoard.board |= (static_cast<uint64_t>(logValue) << shift);  // 设置新值

    return newBoard;
}

BitBoard BitBoard::placeNewTile(Position const& pos, int value) const {
    BitBoard newBoard(*this);

    // 将实际值转换为对数值（例如，2->1, 4->2, 8->3, ...）
    int logValue = static_cast<int>(std::log2(value));

    int shift       = (pos.row * 16) + (pos.col * 4);
    newBoard.board &= ~(0xFULL << shift);                          // 清除该位置的旧值
    newBoard.board |= (static_cast<uint64_t>(logValue) << shift);  // 设置新值

    return newBoard;
}

// 计算一行的移动结果
uint16_t BitBoard::moveRow(uint16_t row, Direction direction) {
    uint8_t tiles[4] = {
        static_cast<uint8_t>((row >> 0) & 0xF),
        static_cast<uint8_t>((row >> 4) & 0xF),
        static_cast<uint8_t>((row >> 8) & 0xF),
        static_cast<uint8_t>((row >> 12) & 0xF)
    };

    // 如果是向右移动，反转数组
    if (direction == RIGHT) {
        std::swap(tiles[0], tiles[3]);
        std::swap(tiles[1], tiles[2]);
    }

    // 移除零并合并相同的数字
    int idx = 0;
    for (int i = 0; i < 4; ++i) {
        if (tiles[i] != 0) {
            tiles[idx++] = tiles[i];
        }
    }

    // 清空剩余位置
    while (idx < 4) {
        tiles[idx++] = 0;
    }

    // 合并相同的数字
    for (int i = 0; i < 3; ++i) {
        if (tiles[i] != 0 && tiles[i] == tiles[i + 1]) {
            tiles[i]++;  // 增加对数值（例如，1->2表示2->4）
            tiles[i + 1] = 0;
        }
    }

    // 再次移除零
    idx = 0;
    for (int i = 0; i < 4; ++i) {
        if (tiles[i] != 0) {
            tiles[idx++] = tiles[i];
        }
    }

    // 清空剩余位置
    while (idx < 4) {
        tiles[idx++] = 0;
    }

    // 如果是向右移动，再次反转数组
    if (direction == RIGHT) {
        std::swap(tiles[0], tiles[3]);
        std::swap(tiles[1], tiles[2]);
    }

    // 将4个4位数字合并回16位行
    return static_cast<uint16_t>(tiles[0]) | (static_cast<uint16_t>(tiles[1]) << 4)
           | (static_cast<uint16_t>(tiles[2]) << 8) | (static_cast<uint16_t>(tiles[3]) << 12);
}

// 计算移动产生的分数
uint16_t BitBoard::calculateScore(uint16_t before, uint16_t after) {
    uint16_t score = 0;

    // 提取before和after中的每个4位数字
    uint8_t beforeTiles[4] = {
        static_cast<uint8_t>((before >> 0) & 0xF),
        static_cast<uint8_t>((before >> 4) & 0xF),
        static_cast<uint8_t>((before >> 8) & 0xF),
        static_cast<uint8_t>((before >> 12) & 0xF)
    };

    uint8_t afterTiles[4] = {
        static_cast<uint8_t>((after >> 0) & 0xF),
        static_cast<uint8_t>((after >> 4) & 0xF),
        static_cast<uint8_t>((after >> 8) & 0xF),
        static_cast<uint8_t>((after >> 12) & 0xF)
    };

    // 计算合并产生的分数
    for (int i = 0; i < 4; ++i) {
        if (afterTiles[i] > 0 && afterTiles[i] > beforeTiles[i]) {
            // 如果after中的数字大于before中的数字，说明发生了合并
            // 分数是合并后的数字的实际值
            score += (1 << afterTiles[i]);
        }
    }

    return score;
}

// 使用内存映射文件初始化表
void BitBoard::initializeTables() {
    QElapsedTimer timer;
    timer.start();
    
    qDebug() << "开始初始化BitBoard表...";
    
    // 打开内存映射文件
    if (!openLookupTableFile()) {
        qWarning() << "无法打开内存映射文件，使用传统方法初始化表";
        initializeTablesTraditional();
        return;
    }
    
    // 检查文件头
    quint32* header = static_cast<quint32*>(mappedData);
    if (header[0] != 0x2048BEEF || header[1] != 1) {
        qWarning() << "查找表文件格式不正确，使用传统方法初始化表";
        closeLookupTableFile();
        initializeTablesTraditional();
        return;
    }
    
    // 获取表数据的指针
    uint16_t* tableData = reinterpret_cast<uint16_t*>(static_cast<char*>(mappedData) + 8); // 跳过8字节的文件头
    
    // 检查表是否已经计算
    bool tablesComputed = false;
    for (int i = 0; i < 65536; ++i) {
        if (tableData[i] != 0) {
            tablesComputed = true;
            break;
        }
    }
    
    if (!tablesComputed) {
        qDebug() << "查找表文件为空，开始计算...";
        
        // 计算所有可能的行状态的移动结果
        #pragma omp parallel for
        for (int row = 0; row < 65536; ++row) {
            // 计算向左移动的结果
            uint16_t leftResult = moveRow(static_cast<uint16_t>(row), LEFT);
            tableData[row] = leftResult;
            tableData[row + 131072] = calculateScore(static_cast<uint16_t>(row), leftResult);
            
            // 计算向右移动的结果
            uint16_t rightResult = moveRow(static_cast<uint16_t>(row), RIGHT);
            tableData[row + 65536] = rightResult;
        }
        
        qDebug() << "查找表计算完成，已保存到文件";
    } else {
        qDebug() << "从文件加载查找表";
    }
    
    // 直接使用内存映射的数据
    moveTable[LEFT] = *reinterpret_cast<std::array<uint16_t, 65536>*>(tableData);
    moveTable[RIGHT] = *reinterpret_cast<std::array<uint16_t, 65536>*>(tableData + 65536);
    scoreTable = *reinterpret_cast<std::array<uint16_t, 65536>*>(tableData + 131072);
    
    tablesInitialized = true;
    
    qDebug() << "BitBoard表初始化完成，耗时" << timer.elapsed() << "毫秒";
}

// 传统方法初始化表
void BitBoard::initializeTablesTraditional() {
    QElapsedTimer timer;
    timer.start();
    
    qDebug() << "使用传统方法初始化BitBoard表...";
    
    // 计算所有可能的行状态的移动结果
    #pragma omp parallel for
    for (int row = 0; row < 65536; ++row) {
        // 计算向左移动的结果
        uint16_t leftResult = moveRow(static_cast<uint16_t>(row), LEFT);
        moveTable[LEFT][row] = leftResult;
        scoreTable[row] = calculateScore(static_cast<uint16_t>(row), leftResult);
        
        // 计算向右移动的结果
        uint16_t rightResult = moveRow(static_cast<uint16_t>(row), RIGHT);
        moveTable[RIGHT][row] = rightResult;
    }
    
    tablesInitialized = true;
    
    qDebug() << "BitBoard表初始化完成，耗时" << timer.elapsed() << "毫秒";
}

BitBoard BitBoard::move(Direction direction) const {
    uint64_t currentBoard = board;
    uint64_t result       = 0;

    if (direction == UP || direction == DOWN) {
        // 转置矩阵
        uint64_t transposed = 0;
        for (int row = 0; row < 4; ++row) {
            for (int col = 0; col < 4; ++col) {
                int fromShift   = (row * 16) + (col * 4);
                int toShift     = (col * 16) + (row * 4);
                uint64_t value  = (currentBoard >> fromShift) & 0xF;
                transposed     |= (value << toShift);
            }
        }
        currentBoard = transposed;

        // 计算实际方向
        Direction actualDirection = (direction == UP) ? LEFT : RIGHT;

        // 对每一行应用移动
        for (int row = 0; row < 4; ++row) {
            int shift          = row * 16;
            uint16_t rowValue  = (currentBoard >> shift) & 0xFF'FF;
            uint16_t newRow    = moveTable[actualDirection][rowValue];
            result            |= (static_cast<uint64_t>(newRow) << shift);
        }

        // 再次转置回来
        uint64_t finalResult = 0;
        for (int row = 0; row < 4; ++row) {
            for (int col = 0; col < 4; ++col) {
                int fromShift   = (row * 16) + (col * 4);
                int toShift     = (col * 16) + (row * 4);
                uint64_t value  = (result >> fromShift) & 0xF;
                finalResult    |= (value << toShift);
            }
        }
        result = finalResult;
    } else {
        // 对每一行应用移动
        for (int row = 0; row < 4; ++row) {
            int shift          = row * 16;
            uint16_t rowValue  = (currentBoard >> shift) & 0xFF'FF;
            uint16_t newRow    = moveTable[direction][rowValue];
            result            |= (static_cast<uint64_t>(newRow) << shift);
        }
    }

    return BitBoard(result);
}

bool BitBoard::isGameOver() const {
    // 如果有空位，游戏没有结束
    if (countEmptyTiles() > 0) {
        return false;
    }

    // 检查是否有可能的移动
    for (int direction = 0; direction < 4; ++direction) {
        BitBoard newBoard = move(static_cast<Direction>(direction));
        if (newBoard.board != board) {
            return false;
        }
    }

    return true;
}

int BitBoard::getMaxTile() const {
    int maxTile = 0;

    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 4; ++col) {
            maxTile = std::max(maxTile, getTile(row, col));
        }
    }

    return maxTile;
}

std::string BitBoard::toString() const {
    std::stringstream ss;

    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 4; ++col) {
            int value = getTile(row, col);
            ss << std::setw(5) << value;
        }
        ss << std::endl;
    }

    return ss.str();
}

void BitBoard::initializeTablesAsync() {
    QMutexLocker locker(&tablesMutex);
    if (!tablesInitialized) {
        initializeTables();
        tablesInitialized = true;
    }
}

bool BitBoard::areTablesInitialized() {
    QMutexLocker locker(&tablesMutex);
    return tablesInitialized;
}

// 添加哈希函数，用于缓存
size_t BitBoard::hash() const {
    // 使用board值作为哈希值
    return static_cast<size_t>(board);
}
